### **biblerhyme.com 서비스 아키텍처 설계**

**1. 개요**

본 문서는 `biblerhyme.com` 웹 서비스의 기술 아키텍처를 정의합니다. 설계 목표는 다음과 같습니다.

*   **빠른 콘텐츠 전송:** 전 세계 어디서든 사용자가 음원을 지연 없이 스트리밍할 수 있어야 합니다.
*   **최고의 사용자 경험:** 현대적인 웹 기술을 사용하여 반응성이 뛰어나고 인터랙티브한 UI/UX를 제공합니다.
*   **검색 엔진 최적화 (SEO):** 구글 등 검색 엔진이 콘텐츠를 쉽게 발견하고 색인을 생성할 수 있어야 합니다.
*   **운영 효율성 및 비용 최적화:** 서버 관리 부담을 최소화하고, 트래픽에 따라 비용이 유연하게 조절되는 효율적인 구조를 지향합니다.

**2. 핵심 아키텍처: Decoupled Jamstack**

사용자에게 콘텐츠를 제공하는 **'서빙(Serving) 시스템'**과, 콘텐츠를 생성하는 **'생성(Generation) 시스템'**을 완전히 분리(Decoupled)합니다. 사용자에게 노출되는 서빙 시스템은 빠르고 가벼운 Jamstack(JavaScript, APIs, Markup) 구조를 채택합니다.

```mermaid
graph TD
    subgraph "사용자 영역"
        User[<i class="fa fa-user"></i> 사용자] --> Vercel{Vercel/CDN}
    end

    subgraph "프론트엔드 (Vercel)"
        Vercel --> NextJS[Next.js App]
    end

    subgraph "백엔드 (AWS)"
        NextJS --> APIGW[API Gateway]
        APIGW --> Lambda[AWS Lambda]
        Lambda --> RDS[DB (PostgreSQL)]
    end

    subgraph "콘텐츠 전송 (AWS)"
        User --> CloudFront[CDN (CloudFront)]
        CloudFront --> S3[S3 Bucket: 음원 파일]
    end

    style User fill:#f9f,stroke:#333,stroke-width:2px
    style Vercel fill:#9cf,stroke:#333,stroke-width:2px
    style CloudFront fill:#9cf,stroke:#333,stroke-width:2px
```
*Note: 위 다이어그램은 mermaid.js 구문으로, 렌더링을 지원하는 뷰어에서 시각적으로 표시됩니다.*

**3. 기술 스택 및 구성 요소**

#### **3.1. 프론트엔드 (Frontend)**

*   **기술:** **React (Next.js)**
*   **선택 이유:**
    *   **SSR/SSG 지원:** 서버사이드 렌더링(SSR)과 정적 사이트 생성(SSG)을 지원하여 초기 로딩 속도가 매우 빠르고 SEO에 절대적으로 유리합니다.
    *   **컴포넌트 기반 개발:** 재사용 가능한 UI 컴포넌트를 통해 개발 및 유지보수가 용이합니다.
*   **호스팅:** **Vercel**
*   **선택 이유:**
    *   **Git 기반 배포:** GitHub에 코드를 푸시하는 것만으로 자동으로 빌드 및 배포가 완료됩니다. (CI/CD 내장)
    *   **글로벌 CDN:** 전 세계에 분산된 엣지 네트워크를 통해 애플리케이션을 사용자 가까이에서 제공하여 로딩 속도를 극대화합니다.

#### **3.2. 백엔드 (Backend)**

*   **기술:** **Serverless API (AWS Lambda + API Gateway)** with Node.js or Python
*   **선택 이유:**
    *   **비용 효율:** API가 호출될 때만 컴퓨팅 자원을 사용하고 비용을 지불합니다. 평소 트래픽이 적을 경우 비용이 거의 발생하지 않습니다.
    *   **자동 확장:** 트래픽이 급증하면 AWS가 자동으로 컴퓨팅 자원을 확장해 주므로, 서버가 다운될 걱정이 없습니다.
    *   **서버리스(Serverless):** 서버를 직접 프로비저닝하거나 관리할 필요가 없어 운영 부담이 없습니다.
*   **역할:** 프론트엔드(Next.js)의 요청에 따라 데이터베이스에서 음원 메타데이터를 조회하여 JSON 형식으로 제공합니다. (예: `GET /api/songs`, `GET /api/songs?book=psalms`)

#### **3.3. 데이터베이스 (Database)**

*   **기술:** **Amazon RDS for PostgreSQL** (클라우드 관리형 PostgreSQL)
*   **선택 이유:** 앞서 '메타데이터 관리 방안'에서 정의한 바와 같이, 안정적인 데이터 관리와 복잡한 조회를 위해 관계형 데이터베이스를 사용합니다. RDS를 사용하면 백업, 복구, 보안 업데이트 등을 AWS가 자동으로 관리해 줍니다.

#### **3.4. 음원 저장 및 전송 (Audio Storage & Delivery)**

*   **저장소:** **AWS S3 (Simple Storage Service)**
*   **전송 네트워크:** **AWS CloudFront (CDN)**
*   **작동 방식:**
    1.  프론트엔드는 백엔드 API로부터 음원의 `audio_url`(S3 주소)을 받습니다.
    2.  사용자가 재생 버튼을 누르면, 브라우저는 이 `audio_url`로 음원을 요청합니다.
    3.  이 요청은 전 세계에 퍼져있는 **CloudFront** 엣지 서버로 전달됩니다.
    4.  CloudFront는 S3 원본 파일의 복사본을 캐싱하여 사용자에게 매우 빠른 속도로 음원을 스트리밍합니다.
    5.  이를 통해 S3의 데이터 전송 비용을 절감하고, 사용자 경험을 극대화하며, 백엔드 서버의 부하를 완전히 제거합니다.

**4. 사용자 데이터 흐름**

1.  사용자가 `biblerhyme.com`에 접속합니다.
2.  Vercel이 Next.js 애플리케이션을 사용자에게 전달합니다.
3.  Next.js 앱은 백엔드 API(`api.biblerhyme.com`)를 호출하여 음원 목록(메타데이터)을 요청합니다.
4.  백엔드 API(Lambda)는 데이터베이스(RDS)를 조회하여 결과를 JSON으로 반환합니다.
5.  Next.js 앱은 받은 데이터로 화면에 음원 목록을 표시합니다.
6.  사용자가 특정 음원을 재생하면, 브라우저는 **CloudFront CDN**을 통해 S3에 저장된 음원 파일을 직접 스트리밍합니다.

**5. 분리된 시스템: 콘텐츠 생성 파이프라인**

앞서 설계한 '콘텐츠 생성 자동화 워크플로우'는 이 서비스 아키텍처와는 **완전히 분리된 별개의 시스템**입니다. 생성 파이프라인은 오프라인으로 작동하며, 그 결과물(MP3 파일, 메타데이터)을 S3와 RDS에 채워 넣는 역할만 수행합니다. 이처럼 두 시스템을 분리함으로써, 콘텐츠 생성 작업이 사용자에게 서비스를 제공하는 데 어떠한 영향도 주지 않도록 보장합니다.